<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:w="tag:fullstack.wiki,2018:ns/" lang="en" dir="ltr">
	<head>
		<meta charset="UTF-8" />
		<title>JSON Schema</title>
		<link rel="stylesheet" href="jsonschema.css" />
		<link rel="stylesheet" href="/+/highlight.js/solarized-light.css" />
	</head>
	<body>
		<main>

<h1>JSON Schema</h1>
<p>
	JSON Schema is a vocabulary for making assertions about JSON documents. You can use a JSON Schema document to annotate and validate other JSON documents.
</p>
<p>
	The official website for JSON Schema is at <a href="https://json-schema.org/">json-schema.org</a>.
</p>

<h2>Uses for JSON Schema</h2>

<dl>
	<dt>Writing tests for JSON documents.</dt><dd>Use JSON Schema in your application tests to ensure that data follows basic constraints, in declarative code instead of procedural code.</dd>
	<dt>Validation of JSON-like data structures.</dt><dd>Most JSON Schema implementations can validate data structures in memory, not just JSON documents in a file. Use JSON Schema to write declarative assertions in your application, and compile them into your application.</dd>
	<dt>Validating user input.</dt><dd>Use JSON Schema to verify the range/types of user input is correct and report problems to users, often in fewer lines of code than can be done by hand.</dd>
	<dt>Describing expected input to users.</dt><dd>Share a JSON Schema to express to other parties what input you're expacting, so they can verify correctness before submission.</dd>
	<dt>Add links to plain JSON APIs.</dt><dd>Use JSON Schema to add link relationships to JSON documents in HTTP APIs, allowing hypermedia user agents to browse the API and improve flexibility.</dd>
	<dt>Describe the structure of JSON documents.</dt><dd>Use JSON Schema to describe what each property in a document means, especially for use in IDE hints, or autogenerated documentation.</dd>
	<dt>API documentation.</dt><dd>Use JSON Schema to describe what each property in a document means, especially for use in IDE hints, or autogenerated documentation.</dd>
</dl>

<h2>When not to use JSON Schema</h2>
<p>JSON Schema does not by itself verify the <i>consistentcy</i> of data: There's no standard mechanism to verify that, for example, a given string is a key in a database, or a value elsewhere in the same document. There are some extensions to provide this functionality, but it is currently out-of-scope of the standard vocabulary.</p>

<h2>Fundementals of JSON Schema Usage</h2>
<p>The JSON document being validated or described we call the instance, and the document containing the description is called the schema.</p>
<p>
	Fundamentally, a schema is a list of rules, collected into a JSON object. The empty object represents every well-formed JSON document, and prohibits nothing:
</p>
<pre type="application/json" w:space="indent">
	{
	}
</pre>
By adding properties to this object, called keywords, you can add constraints or annotations to a JSON document. The name of the keyword is used as the property key, and any arguments to the keyword are put in the property value. JSON Schema lists keywords in an object because most keywords only need to be used once, and most keywords take some sort of argument.
<p>
	One of the most widely used keywords is <code class="json-schema-keyword">"type"</code>, which checks that the type of the JSON value is one of a few specified types (object, array, string, number, boolean, or null). This schema verifies that the document is a string:
</p>
<pre type="application/json" w:space="indent">
	{
		"type": "string"
	}
</pre>
<p>
	This means that objects, arrays, numbers, booleans, and null will cause a validation error when checked against this schema; only strings will pass validation.
</p>
<p>
	The type keyword also accepts an array, if multiple types are acceptable:
</p>
<pre type="application/json" w:space="indent">
	{
		"type": ["string", "number"]
	}
</pre>
<p>
	Some keywords are only checked when the instance is a specific type. For example, the <code class="json-schema-keyword">"minLength"</code> keyword only applies to strings, and the <code class="json-schema-keyword">"minItems"</code> only applies to arrays. This is by design, so that keywords for multiple types may be mixed without interfering with each other. Consider this schema:
</p>
<pre type="application/json" w:space="indent">
	{
		"type": ["string", "number"],
		"exclusiveMinimum": 0
	}
</pre>
<p>
	This schema allows instances to be a string or a number; and if a number, it must be a positive (nonzero) number. If it’s a string, there’s no limit on its contents, it can even be the blank string <code class="json">""</code>, or the a one-character long string zero <code class="json">"0"</code>.
</p>
<p>
	Some keywords take schemas as an argument, and apply those schemas to values within the document. The <code class="json-schema-keyword">"properties"</code> keyword maps schemas onto specific properties in an instance, if those properties exist:
</p>
<pre type="application/json" w:space="indent">
	{
		"type": "object",
		"properties": {
			"id": {"type":"string", "maxLength":"20"},
			"label": {"type":"string", "maxLength":"250"}
		}
	}
</pre>
<p>
	The <code class="json-schema-keyword">"additionalProperties"</code> keyword supplies a schema that is applied to any properties not listed in <code class="json-schema-keyword">"properties"</code> or <code class="json-schema-keyword">"patternProperties"</code>:
</p>
<pre type="application/json" w:space="indent">
	{
		"type": "object",
		"additionalProperties": {"type":"number"},
	}
</pre>
<p>
	This schema verifies that each value in the object is a number.
</p>
<p>
	Any properties not listed are not checked. The <code class="json-schema-keyword">"required"</code> keyword lists properties that must exist:
</p>
<pre type="application/json" w:space="indent">
	{
		"type": "object",
		"required": ["id"],
		"properties": {
			"id": {"type":"string", "maxLength":"20"},
			"label": {"type":"string", "maxLength":"250"}
		}
	}
</pre>
<p>
	Likewise for arrays, the "items" keyword accepts any number of schemas for an array:
</p>
<pre type="application/json" w:space="indent">
	{
		"type": "array",
		"items": [
			{"type":"number"},
			{"type":"number", "minimum":0}
		],
		"additionalItems": {"type":"string"}
	}
</pre>
<p>
	This allows an array, and the first item must be a number, the second item must be a non-negative number, and any items after that must be a string.
</p>
<p>
	Typically, keywords will not interfere with each other's behavior.  However, <code class="json-schema-keyword">"additionalProperties"</code> and <code class="json-schema-keyword">"additionalItems"</code> are two exceptions, where their behavior is influenced by other keywords, and those keywords must be checked first.
</p>
<p>
	Sometimes the same schema is re-used in multiple places. To uniquely identify a schema, they may be given a URI with the <code class="json-schema-keyword">$id</code> keyword:
</p>
<pre type="application/json" w:space="indent">
	{
		"$id": "http://example.com/schema/address",
		"type": "object",
		"properties": {
			"id": {"type":"string", "maxLength":"20"},
			"label": {"type":"string", "maxLength":"250"}
		}
	}
</pre>
<p>
	Then from other schemas, you can import the schema by using the <code class="json-schema-keyword">$ref</code> keyword:
</p>
<pre type="application/json" w:space="indent">
	{
		"$ref": "http://example.com/schema/addres"
	}
</pre>
<p>
	Using <code class="json-schema-keyword">$ref</code> is roughly equivalent to embedding the referenced schema as an item inside allOf, with the URI base changed to the document’s URI.
</p>
<p>
	You may also use <code class="json-schema-keyword">$ref</code> to perform recursion:
</p>
<pre type="application/json" w:space="indent">
	{
		"$id": "http://example.com/schema/root#",
		"type": "object",
		"required": ["id"],
		"properties": {
			"id": { "type": "string", "maxLength": 32 },
			"children": {
				"type": "array",
				"items": { "$ref": "#" }
			}
		}
	}
</pre>
<p>
	Here, the schema describes an object where the "children" property is an array of objects, with the same structure, of unlimited depth. For example:
</p>
<pre type="application/json" w:space="indent">
	{
		"id": "0",
		"children": [
			{
				"id": "1",
				"children": [
					{"id":"2"},
					{"id":"3"}
				]
			},
			{
				"id": "4",
				"children": [
					{"id":"5"},
					{"id":"6"}
				]
			}
		]
	}
</pre>
<p>
	Note how the value for <code class="json-schema-keyword">$ref</code> may be a URI Reference: it permits relative references, in addition to a complete, fully qualified URI.
	Resolving a reference into a full URI is done the same way that Web browsers do, against the URI of the document it’s inside.
	The <code class="json-schema-keyword">$id</code> keyword may itself be a URI Reference, though you should always use a full URI.
</p>
<p>
	If a relative reference is encountered, it works the same way as a base tag in HTML: it is resolved against the URI would have been (either the URL used to download the document, or the URI of the parent schema); then any other URI References in the document are resolved against this.
</p>


		</main>
	</body>
</html>
